from __future__ import unicode_literals

try:
    from pathlib import Path
except ImportError:
    from pathlib2 import Path
try:
    from urllib.parse import urlparse
except ImportError:
    from urlparse import urlparse

import os
from posixpath import basename

import wrapt
from django.conf import settings
from django.core import validators
from django.db import models
from django.utils.functional import cached_property
from django.utils.text import slugify
from django.utils.timezone import now
import ruamel.yaml

from . import signals, git


CONFIG_FILE_NAME = ".mote.yml"


class MoteRepositoryError(Exception):
    """A container for errors generated by the Mote Repository Model."""


class RepositoryAlreadyExists(MoteRepositoryError):
    """The repo already exists at the given location."""


class RepositoryNotReady(MoteRepositoryError):
    """The repo is not ready."""


def pattern_engines_from_settings():
    choices = getattr(settings, "MOTE_PATTERN_ENGINES", {})
    return [(k, k.capitalize()) for k in choices.keys()]


@wrapt.decorator
def require_ready_state(wrapped, instance, args, kwargs):
    """An Model instance method that checks a ready flag and raises a
    RepositoryNotReady exception if it is False.
    """
    if not instance.ready:
        raise RepositoryNotReady
    return wrapped(*args, **kwargs)


# Custom repo location class for more humane repo clone names.
class MoteRepositoryLocation(git.RepositoryLocation):
    def __init__(self, working_directory, repository_url):
        self.working_directory = working_directory
        self.url = repository_url
        self.repository_url = urlparse(repository_url)
        # root_path is the container directory that will hold the core clone
        # along with any worktrees created later.
        self.root_path = Path(working_directory)
        # path is where the core clone is located. Defaults to a full hash
        # of the repo URL.
        self.path = self.root_path / self.project_name

    def worktree_path(self, branch_name):
        wt_name = "{project}-{branch}".format(
            project=self.project_name,
            branch=slugify(branch_name)
        )
        return self.root_path / wt_name

    @property
    def project_name(self):
        """Guess the project name from the URL."""
        return Repository.get_name_from_url(self.url)


class RepositoryManager(models.Manager):
    def get_or_create_from_url(self, url):
        location = MoteRepositoryLocation(
            settings.REPOSITORY_BASE_DIR,
            url
        )
        handler = git.Repository(location, settings.GIT_BINARY)
        path = str(handler.location.path)
        return self.get_or_create(
            fetch_url=url, defaults={"path": path}
        )


class Repository(models.Model):
    PATTERN_ENGINE_CHOICES = pattern_engines_from_settings()

    fetch_url = models.URLField(
        unique=True,
        validators=[
            validators.URLValidator(schemes=settings.ALLOWED_URL_SCHEMES)
        ]
    )
    path = models.CharField(max_length=255, unique=True)
    pattern_engine = models.CharField(
        max_length=255,
        choices=PATTERN_ENGINE_CHOICES,
        default="jinja2"
    )
    ready = models.BooleanField(default=False)
    updated_on = models.DateTimeField(null=True)
    objects = RepositoryManager()

    def save(self, *args, **kwargs):
        should_fetch = False
        if self._state.adding:
            # Always fetch the first time.
            should_fetch = True
        else:
            # Otherwise only fetch if the fetch_url has changed.
            if self.fetch_url != self._loaded_values["fetch_url"]:
                should_fetch = True
        super(Repository, self).save(*args, **kwargs)
        # Only initiate the fetch after the save has completed successfully.
        if should_fetch:
            signals.fetch_repository.send(
                sender=self.__class__,
                repository_pk=self.pk
            )

    @property
    def default_worktree(self):
        return self.worktrees.filter(default=True).first()

    @classmethod
    def from_db(cls, db, field_names, values):
        # Override loading the instance from the db so we can store the
        # loaded values separately for change tracking purposes.
        instance = super(Repository, cls).from_db(db, field_names, values)
        instance._loaded_values = dict(zip(field_names, values))
        return instance

    @staticmethod
    def get_name_from_url(url):
        parsed_url = urlparse(url)
        path = basename(parsed_url.path)
        git_in_path = path.find(".git")
        if git_in_path > 0:
            path = path[:git_in_path]
        return path

    # --- Git Repository handling functions ---

    @cached_property
    def handler(self):
        # NOTE: This property will point to the wrong repo if fetch_url or path
        # are changed on the instance and hence needs to be invalidated when
        # that happens ("del <instance>.handler" will invalidate).
        location = MoteRepositoryLocation(
            settings.REPOSITORY_BASE_DIR,
            self.fetch_url
        )
        handler = git.Repository(location, settings.GIT_BINARY)
        return handler

    def clone(self):
        if not self.handler.ready:
            try:
                self.handler.clone()
            except git.RepositoryError as exc:
                # Cloning the repository has failed, log the failure.
                message = str(exc)
                raise MoteRepositoryError(message)

            self.ready = True
            self.updated_on = now()
            self.save()
        else:
            raise RepositoryAlreadyExists

    @require_ready_state
    def pull(self):
        """Shortcut to pulling the default worktree.

        This method will update the repository relevant fields and save
        the instance.
        """
        self.handler.update()
        self.ready = True
        self.updated_on = now()
        self.save()

    @cached_property
    @require_ready_state
    def branches(self):
        """Lookup all available branches on the repo's remotes.

        This queries the remotes directly, so it is cached.
        """
        return self.handler.branches()

    @require_ready_state
    def sync_worktrees(self):
        """Create or update Worktree models for all the currently defined
        worktrees in the git repository.
        """
        if not self.ready:
            raise RepositoryNotReady

        for wt in self.handler.worktrees():
            worktree, created = self.worktrees.get_or_create(
                branch=wt.branch,
                defaults={
                    "path": wt.path,
                    "ready": True,
                    "head": wt.head,
                    "updated_on": now()
                }
            )
            if created:
                worktree.load_config_from_repo()

        # If there isn't a default worktree set yet, set it to the first one.
        if self.default_worktree is None:
            wt = self.worktrees.all().first()
            wt.default = True
            wt.save()

    @require_ready_state
    def pull_all_worktrees(self):
        for worktree in self.worktrees.filter(ready=True):
            worktree.pull()

    @require_ready_state
    def create_worktree(self, branch_name):
        wt = self.handler.add_worktree(branch_name)
        worktree, created = self.worktrees.get_or_create(
            branch=wt.branch,
            defaults={
                "path": wt.path,
                "ready": True,
                "head": wt.head,
                "updated_on": now()
            }
        )
        return worktree


class Worktree(models.Model):
    PATTERN_ENGINE_CHOICES = pattern_engines_from_settings()

    repository = models.ForeignKey(Repository, related_name="worktrees")
    branch = models.CharField(max_length=255)
    path = models.CharField(max_length=255)
    ready = models.BooleanField(default=False)
    head = models.CharField(max_length=255, default="")
    default = models.BooleanField(default=False)
    updated_on = models.DateTimeField(null=True)
    library_root_path = models.CharField(
        max_length=255,
        default="",
        help_text="Relative path to the location of the pattern library"
    )
    static_path = models.CharField(
        max_length=255,
        default="",
        help_text="Relative path to the static files target build directory"
    )
    static_build_cmd = models.CharField(max_length=255, default="")
    static_setup_cmd = models.CharField(max_length=255, default="")
    pattern_engine = models.CharField(
        max_length=255,
        choices=PATTERN_ENGINE_CHOICES,
        default="jinja2"
    )

    @require_ready_state
    def pull(self):
        self.repository.handler.update_worktree(self.branch)
        self.updated_on = now()
        self.save()

    @property
    def patterns_path(self):
        return (self.path, self.library_root_path)

    @require_ready_state
    def load_config_from_repo(self):
        path = os.path.join(self.path, CONFIG_FILE_NAME)
        if not os.path.exists(path):
            return
        with open(path, "r") as fp:
            data = ruamel.yaml.load(fp)
            self.pattern_engine = data.get("pattern_engine", "jinja2")
            self.library_root_path = data.get("library_root_path", "")
            self.static_path = data.get("static_path", "")
            self.static_build_cmd = data.get("static_build_cmd", "")
            self.static_setup_cmd = data.get("static_setup_cmd", "")
            self.save()

    def static_link_name(self, project_id):
        pl = self.repository.project_link.get(project_id=project_id)
        return "{repo}-{branch}".format(
            repo=pl.slug,
            branch=self.branch
        )

    @require_ready_state
    def link_static_directory(self, project_id):
        if not os.path.exists(settings.MOTE_REPO_STATIC_ROOT):
            os.mkdir(settings.MOTE_REPO_STATIC_ROOT)
        link_target = os.path.join(
            settings.MOTE_REPO_STATIC_ROOT,
            self.static_link_name(project_id)
        )
        os.symlink(os.path.join(self.path, self.static_path), link_target)
