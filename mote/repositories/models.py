from __future__ import unicode_literals

try:
    from urllib.parse import urlparse
except ImportError:
    from urlparse import urlparse

from posixpath import basename

import wrapt
from django.conf import settings
from django.core import validators
from django.db import models
from django.utils.timezone import now
from django.utils.functional import cached_property
from columbia import git

from . import signals


class MoteRepositoryError(Exception):
    """A container for errors generated by the Mote Repository Model."""


class RepositoryAlreadyExists(MoteRepositoryError):
    """The repo already exists at the given location."""


class RepositoryNotReady(MoteRepositoryError):
    """The repo is not ready."""


@wrapt.decorator
def require_ready_state(wrapped, instance, args, kwargs):
    """An Model instance method that checks a ready flag and raises a
    RepositoryNotReady exception if it is False.
    """
    if not instance.ready:
        raise RepositoryNotReady
    return wrapped(*args, **kwargs)


class RepositoryManager(models.Manager):
    def get_or_create_from_url(self, url):
        handler = git.setup_repository(
            settings.REPOSITORY_BASE_DIR,
            url,
            binary=settings.GIT_BINARY
        )
        path = str(handler.location.path)
        return self.get_or_create(
            fetch_url=url, defaults={"path": path}
        )


class Repository(models.Model):
    fetch_url = models.URLField(
        unique=True,
        validators=[
            validators.URLValidator(schemes=settings.ALLOWED_URL_SCHEMES)
        ]
    )
    path = models.CharField(max_length=255, unique=True)
    patterns_path = models.CharField(max_length=255, default="")
    ready = models.BooleanField(default=False)
    updated_on = models.DateTimeField(null=True)
    objects = RepositoryManager()

    def save(self, *args, **kwargs):
        should_fetch = False
        if self._state.adding:
            # Always fetch the first time.
            should_fetch = True
        else:
            # Otherwise only fetch if the fetch_url has changed.
            if self.fetch_url != self._loaded_values["fetch_url"]:
                should_fetch = True
        super(Repository, self).save(*args, **kwargs)
        # Only initiate the fetch after the save has completed successfully.
        if should_fetch:
            signals.fetch_repository.send(
                sender=self.__class__,
                repository_pk=self.pk
            )

    @property
    def default_worktree(self):
        return self.worktrees.filter(default=True).first()

    @classmethod
    def from_db(cls, db, field_names, values):
        # Override loading the instance from the db so we can store the
        # loaded values separately for change tracking purposes.
        instance = super(Repository, cls).from_db(db, field_names, values)
        instance._loaded_values = dict(zip(field_names, values))
        return instance

    @staticmethod
    def get_name_from_url(url):
        parsed_url = urlparse(url)
        path = basename(parsed_url.path)
        git_in_path = path.find(".git")
        if git_in_path > 0:
            path = path[:git_in_path]
        return path

    # --- Git Repository handling functions ---

    @cached_property
    def handler(self):
        # NOTE: This property will point to the wrong repo if fetch_url or path
        # are changed on the instance and hence needs to be invalidated when
        # that happens ("del <instance>.handler" will invalidate).
        handler = git.setup_repository(
            settings.REPOSITORY_BASE_DIR,
            self.fetch_url,
            binary=settings.GIT_BINARY,
        )
        return handler

    def clone(self):
        if not self.handler.ready:
            try:
                self.handler.clone()
            except git.RepositoryError as exc:
                # Cloning the repository has failed, log the failure.
                message = str(exc)
                raise MoteRepositoryError(message)

            self.ready = True
            self.updated_on = now()
            self.save()
        else:
            raise RepositoryAlreadyExists

    @require_ready_state
    def pull(self):
        """Shortcut to pulling the default worktree.

        This method will update the repository relevant fields and save
        the instance.
        """
        self.handler.update()
        self.ready = True
        self.updated_on = now()
        self.save()

    @cached_property
    @require_ready_state
    def branches(self):
        """Lookup all available branches on the repo's remotes.

        This queries the remotes directly, so it is cached.
        """
        return self.handler.branches()

    @require_ready_state
    def sync_worktrees(self):
        """Create or update Worktree models for all the currently defined
        worktrees in the git repository.
        """
        if not self.ready:
            raise RepositoryNotReady

        for wt in self.handler.worktrees():
            worktree, created = self.worktrees.get_or_create(
                branch=wt.branch,
                defaults={
                    "path": wt.path,
                    "ready": True,
                    "head": wt.head,
                    "updated_on": now()
                }
            )

    @require_ready_state
    def pull_all_worktrees(self):
        for worktree in self.worktrees.filter(ready=True):
            worktree.pull()

    @require_ready_state
    def create_worktree(self, branch_name):
        wt = self.handler.add_worktree(branch_name)
        worktree, created = self.worktrees.get_or_create(
            branch=wt.branch,
            defaults={
                "path": wt.path,
                "ready": True,
                "head": wt.head,
                "updated_on": now()
            }
        )
        return worktree


class Worktree(models.Model):
    repository = models.ForeignKey(Repository, related_name="worktrees")
    branch = models.CharField(max_length=255)
    path = models.CharField(max_length=255)
    ready = models.BooleanField(default=False)
    head = models.CharField(max_length=255, default="")
    default = models.BooleanField(default=False)
    updated_on = models.DateTimeField(null=True)

    @require_ready_state
    def pull(self):
        self.repository.handler.update_worktree(self.branch)
        self.updated_on = now()

    @property
    def patterns_path(self):
        return (self.path, self.repository.patterns_path)
